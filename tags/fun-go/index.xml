<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fun-go on Awesome Patrick</title>
    <link>https://tramamte.github.io/tags/fun-go/</link>
    <description>Recent content in fun-go on Awesome Patrick</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy2022 Patrick Yu. All rights reserved.</copyright>
    <lastBuildDate>Wed, 20 Mar 2019 22:29:30 +0900</lastBuildDate><atom:link href="https://tramamte.github.io/tags/fun-go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>구조체 초기화 방법</title>
      <link>https://tramamte.github.io/2019/03/20/struct-initialize/</link>
      <pubDate>Wed, 20 Mar 2019 22:29:30 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2019/03/20/struct-initialize/</guid>
      <description>C 구조체 초기화 다음 C 구조체 초기화 방법 중 문법에 위배되는 것은? (단, C99 기준) struct MyStruct { int a; int b; }; // method 1 struct MyStruct m1 = {0, 1}; // method 2 struct MyStruct m2; m2 = (struct MyStruct){0, 1}; // method 3 struct { int</description>
    </item>
    
    <item>
      <title>배열, 슬라이스 그리고 맵</title>
      <link>https://tramamte.github.io/2018/09/05/array-slice-and-map/</link>
      <pubDate>Wed, 05 Sep 2018 23:57:07 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/09/05/array-slice-and-map/</guid>
      <description>Go의 built-in 자료구조인 배열, 슬라이스, 맵에 대해 자세히 살펴보자. 크기 배열, 슬라이스, 맵은 모두 복수의 요소를 저장할 수 있다. 따라서 몇 개의 요소를 가지고 있는</description>
    </item>
    
    <item>
      <title>상수에 대한 오해</title>
      <link>https://tramamte.github.io/2018/07/24/constant-misunderstanding/</link>
      <pubDate>Tue, 24 Jul 2018 22:47:49 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/07/24/constant-misunderstanding/</guid>
      <description>우선 C/C++에서 상수를 만드는 키워드인 const와 final에 대해 간략히 정리해보자. C/C++ const의 역할 변수의 읽기전용 설정 = 상수화 (C++) 멤버 함수의</description>
    </item>
    
    <item>
      <title>특수 함수들</title>
      <link>https://tramamte.github.io/2018/07/10/init-and-main/</link>
      <pubDate>Tue, 10 Jul 2018 19:40:25 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/07/10/init-and-main/</guid>
      <description>본문 중 심볼(symbol)에 대한 내용은 편의상 리눅스 환경에서 빌드한 바이너리를 readelf 명령으로 확인한 결과입니다. C/C++, Java에서 가장 특이한 함수는 누가 뭐래</description>
    </item>
    
    <item>
      <title>정수형 상수의 내부 처리</title>
      <link>https://tramamte.github.io/2018/07/03/deep-inside-constants/</link>
      <pubDate>Tue, 03 Jul 2018 22:35:19 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/07/03/deep-inside-constants/</guid>
      <description>이 글은 마지막 commit id가 4ba5527&amp;hellip;인 Go 소스 코드를 기준으로 합니다. 함수명, 변수/상수명, 변수/상수값 등은 버전에 따라 다를 수 있습니</description>
    </item>
    
    <item>
      <title>봉인해제 switch</title>
      <link>https://tramamte.github.io/2018/06/20/fun-switch/</link>
      <pubDate>Wed, 20 Jun 2018 22:40:39 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/06/20/fun-switch/</guid>
      <description>Go의 switch 작성 규칙은 다음과 같다. SwitchStmt = ExprSwitchStmt | TypeSwitchStmt . 이 중 ExprSwitchStmt 규칙은 다음과 같다. ExprSwitchStmt = &amp;#34;switch&amp;#34; [ SimpleStmt &amp;#34;;&amp;#34; ] [ Expression ] &amp;#34;{&amp;#34; { ExprCaseClause } &amp;#34;}&amp;#34; . ExprCaseClause = ExprSwitchCase &amp;#34;:&amp;#34; StatementList . ExprSwitchCase = &amp;#34;case&amp;#34; ExpressionList | &amp;#34;default&amp;#34; . 자세히 보면 switch 뒤에</description>
    </item>
    
    <item>
      <title>패키지, 임포트에 대한 심화 학습</title>
      <link>https://tramamte.github.io/2018/06/14/fun-packages-and-import/</link>
      <pubDate>Thu, 14 Jun 2018 18:24:57 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/06/14/fun-packages-and-import/</guid>
      <description>Go도 당연히 다른 언어처럼 작성한 코드의 재사용이 가능하다. 쉬이 예상 가능하듯, 패키지를 만들고 이를 임포트해 재사용할 수 있다. 그런데 Go는 C++이나 Ja</description>
    </item>
    
    <item>
      <title>별 것 없을 것 같은 상수의 별 것</title>
      <link>https://tramamte.github.io/2018/06/07/fun-constants/</link>
      <pubDate>Thu, 07 Jun 2018 18:32:17 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/06/07/fun-constants/</guid>
      <description>상수의 타입과 한계 명시적이지 않은 듯 명시적인 Go에서 한 것처럼 reflect 패키지를 이용해 타입을 명시하지 않은 상수의 타입에 대해 알아보자. package main import &amp;#34;fmt&amp;#34; import &amp;#34;reflect&amp;#34; func main() { const A =</description>
    </item>
    
    <item>
      <title>명시적이지 않은 듯 명시적인 Go</title>
      <link>https://tramamte.github.io/2018/06/05/fun-variables-and-types/</link>
      <pubDate>Tue, 05 Jun 2018 12:55:40 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/06/05/fun-variables-and-types/</guid>
      <description>Go는 변수를 선언할 때 초기값을 같이 입력하면 굳이 타입을 명시하지 않아도 된다. var i = 1 f := 3.14 c := 1.0 + 1.0i 그렇다면 이 경우 i, f, c의 타입은 각각 어떻게 될까? G</description>
    </item>
    
    <item>
      <title>간단하거나, 복잡하거나. 세미콜론</title>
      <link>https://tramamte.github.io/2018/05/30/fun-semicolons/</link>
      <pubDate>Wed, 30 May 2018 23:08:20 +0900</pubDate>
      
      <guid>https://tramamte.github.io/2018/05/30/fun-semicolons/</guid>
      <description>Go는 lexer가 세미콜론을 자동으로 삽입하기 때문에 직접 소스코드에 입력할 경우가 거의 없다. Go 언어의 장점 중 하나로 얘기되지만, Go를 처음 접하는, 세미</description>
    </item>
    
  </channel>
</rss>
